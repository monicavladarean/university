from Domain.State import State
import numpy as np
from copy import deepcopy

class HillClimbingAlgorithm(object):
    def __init__(self,n,nrOfTrials):
        self.n = n  #matrix dimensions
        self.state = self.getInitialIndivid()
        self.numberofTrials=nrOfTrials
        #print("first"+str(self.state))
        self.mutationFactor = (n * (n - 1)) * 2  #number big enough for the fitness func to not return neg nrs

    def getInitialIndivid(self):
        #a matrix (everytime a different one)
        state = []
        for i in range(2*self.n): #we have 2*n permutations
            permutation = np.random.permutation(self.n)
            for j in range(len(permutation)):
                #add 1 to be like in the example
                permutation[j]+=1
            permutation=tuple(permutation)
            state.append(permutation)
        individ=State(state)
        return individ

    def fitnessFunction(self,state):
        #ret a number: the bigger, the closer you are to the solution
        #checks the permutations in the state and gives a result based on how close to the sol is this state
        state_vals=state.get_vals()
        version1=0 #it would be perfect to remain 0 for it to be a sol

        #check the lines
        for i in range(self.n):
            l=[]
            for j in range(self.n):
                l.append(state_vals[i][j]) #put the permutations from lines in l
            #get how many perms are the same: if 0 => all unique => very close to sol
            version1+=len(l)-len(set(l)) #set holds only unique perm from l

        #check the columns
        version2=0
        for i in range(self.n):
            l=[]
            for j in range(self.n,self.n*2):
                l.append(state_vals[j][i]) #perms from columns in l
            version2+=len(l)-len(set(l))

        #check that all pairs of permutations are different, no matter the position
        version3=0
        l=[]
        for i in range(self.n):
            j=self.n+i #this is how we get the second part of the pair (i,j) from state
            for k in range(self.n):
                l.append((state_vals[i][k],state_vals[j][k])) #here we add pairs of permutations from the state
        version3+=len(l)-len(set(l))

        return self.mutationFactor-version3-version2-version1


    def keyGeneratorForSorting(self,state):
        #returns the fitness for a state
        return self.fitnessFunction(state)

    def findBestNeighbour(self):
        #returns the best neighbour given by only changing one permutation in the state
        neighbours=[] #list of neighbours
        for i in range(self.n*2):
            neighbour=deepcopy(self.state) #generated by changing a perm
            neighbour_vals=neighbour.get_vals()
            neighbour_vals[i]=np.random.permutation(self.n) #we change the perm
            for j in range(self.n):
                neighbour_vals[i][j]+=1 #to be like in example
            neighbour_vals[i]=tuple(neighbour_vals[i])
            neighbour.set_vals(neighbour_vals)
            neighbours.append(neighbour)

        #sort neighbours to get the best in front
        neighbours.sort(key=self.keyGeneratorForSorting,reverse=True)

        #check if the best neighbour is better than the initial state
        if self.fitnessFunction(neighbours[0])>self.fitnessFunction(self.state):
            return neighbours[0]
        else:
            return self.state

    def HillClimbing(self):
        #choose the best choice of next always, to get to a solution or not in a number of trials
        #we start from a square randomly generated and we always change it or not to get to the best solution
        l=[] #we put here identical states to know when to stop in case of no solution
        while len(l)<self.numberofTrials:
            if self.fitnessFunction(self.state)==self.mutationFactor:
                print("solution:\n"+str(self.state))
                return self.state
            self.state=self.findBestNeighbour()
            #print("len"+str(len(l))+"state:\n"+str(self.state))
            if self.state in l:
                l.append(self.state) #we put the state if it hasn't changed
            else:
                l=[self.state] #else we reset the list
        print("no sol")

